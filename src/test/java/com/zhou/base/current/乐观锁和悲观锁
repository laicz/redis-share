悲观锁：
    悲观锁总是认为情况是最坏的，在获取资源的时候就对资源进行锁定，知道更新完成后，才会释放资源，
    数据库中的行锁，表锁，写锁，读锁，以及Java中的synchronized及ReentrantLock都是悲观锁

乐观锁：
    总是认为情况是最好的，在获取资源的时候不对资源进行锁定，当更新资源的时候，利用版本号机制和Cas算法实现，
    Atomic包下的原子类就是使用乐观锁的实现

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，
像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，
加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，
这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适

乐观锁的实现机制
①：使用版本号实现

②：使用CAS算法实现

乐观锁的缺点
①：ABA问题
②：导致CPU的空轮询
③：只能保证一个共享变量的原子操作

乐观锁：读多写少，竞争压力小
悲观锁：写多情景，竞争压力大

 Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。
 但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁
 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，
 基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，
 可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。